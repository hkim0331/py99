[
 ;; 小手調べ
 {:problem "'Hello, Python!' を画面にプリントしなさい。"}

 {:problem "+, -, *, **, /, //, % はそれぞれ何を計算する演算子か。"}

 {:problem "1 + 2 を評価すると 3 を返し、123 + 3 は 126 を返す。
           '1' + '2' は何を返すか？'123' * 3 は？"}

 ;; difference between `print` and `return`
 {:problem "関数 hello_(s) を定義しなさい。
            引数の s は文字列。
            hello_('Japan') は 'Hello, Japan!' をプリントする。"}

 {:problem "関数 hello(s) を定義しなさい。
           引数の s は文字列。hello('Japan') は文字列 'Hello, Japan!' を返す。"
  :test "def test_hello( ):
  assert hello('Japan') == 'Hello, Japan!'
  assert hello('Good bye') == 'Hello, Good bye!'"}

 {:problem "1 > 0 の戻り値は何か？ 2 > 1 の戻り値は何か？戻り値とは何か？"}

 ;; input( )
 {:problem "数をキーボードから入力、それに 1 を足した数をプリントする関数
            add1_( )."}

 ;; numerical
 {:problem "数 x, y を引数にとり、
            それらを足した数を戻り値とする関数 add2(x, y)."
  :test "def test_add2():
    assert add2(1,2) == 3
    assert add2(-10,-10) == -20
    assert add2(123, 234) == 357
    assert add2(0.0, 0) == 0"}

 {:problem "数 x, y を引数にとり、
            それらを足した数をプリントする関数 add2_(x, y)."}

 {:problem "円の半径を引数にとり、その円の面積を戻り値とする関数en(r)."
  :test "def test_en():
    assert en(1) - 3.14 < 0.01
    assert en(10) - 314 < 1.0
    assert en(-1) == None"}

 {:problem "円の半径をキーボードから読み、
            その円の面積をプリントする関数 void en_( )."}

 {:problem "整数 x, y を引数にとり、それらの和、差、積、商をプリントする関数
            arithmetic_(x, y)."}

 {:problem "数 x を引数に取り、それが負数だったら -1, ゼロと等しければ 0,
            正数であれば 1 を返す関数 sign(x)."
  :test "def test_sign( )
  assert sign(-100)==-1
  assert sign(0)==0
  assert sign(-0)==0
  assert sign(0.0)==0
  assert sign(3.14)==1"}

 {:problem "整数 x を引数にとり、それが偶数であれば True、
            奇数だったら False を返す関数 is_even(x)."
  :test "def test_is_even( ):
  assert is_even(0)
  assert not is_even(1)
  assert is_even(100)
  assert is_even(-100)
  assert not is_even(-99)"}

 {:problem "キーボードから整数ひとつを入力し、それが偶数だったら '偶数です'、
            奇数だったら '奇数です' とプリントする関数 parity_( )."}

 {:problem "彼・彼女の年齢を y とする。彼・彼女がティーンエイジャーだったら True、
  そうでなければ False を返す関数 is_teenage(y)."
  :test "def test_is_teenage( ):
  assert not is_teenage(10)
  assert not is_teenage(12)
  assert not is_teenage(5)
  assert is_teenage(17)
  assert not is_teenage(20)"}

 ;; define functions using defined functions
 
 ;; calendar
 {:problem "西暦 year を引数にとり昭和、平成、令和の和暦を表す文字列を返す関数
            era(year). era(2022)は '令和4年' を返す。
            1926年、1989年、2019年はそれぞれ
            '昭和元年'、'平成元年'、'令和元年'を返すこと。"
  :test "def test_era( ):
  assert era(1926)=='昭和元年'
  assert era(1989)=='平成元年'
  assert era(2019)=='令和元年'
  assert era(1984)=='昭和59年'
  assert era(2013)=='平成25年'
  assert era(2022)=='令和4年'"}

 {:problem "西暦 year を引数にとり、閏年であれば True、
            そうでなければ False を返す関数 is_leap(year).
            西暦が 4 で割り切れれば閏年。ただし、100 で割り切れる時は平年。
            ただし、400 で割り切れる時は閏年。"
  :test "def test_add2():
    assert add2(1,2) == 3
    assert add2(-10,-10) == -20
    assert add2(123, 234) == 357
    assert add2(0.0, 0) == 0"}

 {:problem "hh 時 mm 分 ss 秒の hh, mm, ss を引数にとり、
            00 時 00 分 00 秒からの通算秒に変換した整数を戻り値とする関数
            time_to_int(h, m, s)."}

 {:problem "時刻 h1:m1:s1 と 時刻 h2:m2:s2 の間の秒数を整数で返す関数
            sec_between(h1, m1, s1, h2, m2, s2)."}

 {:problem "平年の 1 月 1 日から同年 mm 月 dd 日までの日数を返す関数
            days(mm, dd)."}

 {:problem "y1 年 m1 月 d1 日から y2 年 m2 月 d2 月までの日数を返す関数
            days_between(y1, m1, d1, y2, m2, d2).
            自分は今日まで何日生きてきましたか?"}

 ;; define functions using defined functions.
 {:problem "二つの数 x, y のどちらか大きい方を返す関数 max2(x, y).
            ビルトイン関数の max を使うのは反則とする。"
  :teset "def max2(x,y):
  if x>y:
    return x
  else:
    return y"}

 {:problem "三つの数 x, y, z の最大値を返す関数 max3(x, y, z).
           ビルトイン関数の max を使うのは反則とする。"}

 {:problem "リスト xs 中の要素の最大値を返す関数 max_in_list(xs).
            ビルトイン関数の max を使うのは反則とする。"}

 ;; smart conditionals
 {:problem "3 つの整数を引数とし、
            それらの長さを各辺とする三角形がありうるかどうかを判定する関数
            is_triangle(int x,  y,  z)."}

 ;; iteration, loop
 {:problem "1 + 2 + ... + n を求める関数 sum_int(n)."
  :test ""}

 {:problem "n~m の整数のうち、偶数だけの和を求める関数 sum_evens(n,m)"
  :test ""}

 {:problem "整数 n から m までの二乗和を求める関数 sum2(n, m)."}

 {:problem "整数 n を引数とし、それが 3 の倍数だったら 1、
            5 の倍数だったら 2、
            3 の倍数でもあり、かつ、5 の倍数でもあったら 3、
            いずれでもなかったら 0 を返す関数 fz(int n)."
  :test ""}

 {:problem "fz(1) + fz(2) + ... + fz(n) を求める関数 sum_fz(n)."}

 {:problem "正の整数 n の階乗 n! を求める関数 factorial(n)."}

 ;; statistics
 {:problem "リスト xs 中の要素の平均値を返す関数 mean(xs).
            numpy.mean を使うのは反則とする。"}

 {:problem "リスト xs の中央値を返す関数 median(xs).
            numpy.median を使うのは反則とする。"}

 ;;
 {:problem "要素が整数であるリスト xs の最頻値を返す関数mod(xs).
            numpy.mod を使うのは反則とする。"}

 ;; sorting
 {:problem "ビルトイン関数の sorted( ), list クラスの sort( ) メソッドを使わずに、
            リスト xs の要素を小さい順に並べ替えたリストを返す関数 my_sort(xs)
            を定義しなさい。"}

 ;; randoms
 ;;
 ;; >>> import random
 ;; >>> random.seed( )
 {:problem "n &le; r &lt; m の整数乱数 r を返す関数 rand_int(n, m)."}

 {:problem "それぞれが 0 &le; r &lt; n の整数乱数 m 個のリストを返す関数
            list_randoms(n, m)."}

 {:problem "rs = list_randoms(n, m) で作った配列 rs 中にみつからない
            0 ~ n-1 の数をリストで返す関数 find_not(rs,  n)."}

 {:problem "rs 中に一番たくさん重複して現れる数を返す関数は my-mode(rs)."}

;; {:problem "int * shuffle(int n) を定義せよ。戻り値は 0~n-1 の n 個の正整数が重複なく順番バラバラに入った配列。完成するとビンゴゲームに使えるぞ。関数名を bingo( ) にしようか。"}

 ;; coercion between int and str
 {:problem "整数 n は何桁あるかを返す関数 digits(n)."}

 {:problem "整数 n の各桁の総和を返す関数 sum_of_digits(n).
            sum_of_digits(12345) の戻り値は 15. "}

 {:problem "整数 n の各桁の数字を逆転した整数を返す関数 reverse_int(n)."}


 ;; palindrome
 {:problem "左右どちらから読んでも同じ値になる数を回文数という。
            整数 n が回文数かどうかを判定する関数 is_palindrome(n)."}

 {:problem "2桁の数の積で表される回文数のうち、最大のものは 9009 = 91 × 99 である。
            3桁の数の積で表される回文数の最大値を求めよ"}

 ;; divisors, gcd
 {:problem "n 以下の整数のうち、もっとも約数の多い数を返す関数 most_divisors(n).
            most_divisors(1000)の戻り値は 840."
  :test ""}

 {:problem "整数 n を引数とし、
            その約数の合計を戻り値とする関数 sum_of_divisors(int n)."
  :test ""}

 {:problem "整数 n を引数とし、その約数のリストを返す関数 divisors(n)."
  :test ""}

 {:problem "math.gcd( ) を使わずに、
           正の整数 x, y の最大公約数を返す関数 gcd2(x, y) を定義しなさい。"
  :test""}

 {:problem "正の整数 x, y z の最大公約数を返す関数 gcd3(x, y, z) を定義しなさい."
  :test ""}

 {:problem "正の整数のリスト xs を引数に取り、
            xs に含まれる整数すべてのの最大公約数を返す関数 gcd_all(xs)."
  :test ""}

 ;; perfect number
 {:problem "n よりも大きい完全数を求める関数 next_perfect(n).
            next_perfect(28) はきっと 496。"
   :test ""}

 ;; primes
 {:problem "正の整数 n を引数に取り、n が素数であれば True、
            そうでなければ False を返す関数 is_prime(n)."}

 {:problem "正の整数 n を引数に取り、
            n 以下の素数は何個あるかを戻り値とする関数 primes(n).
            primes(10000) の戻り値はおそらく 1229."}

 {:problem "正数 n を超えない最大の素数を返す関数 max_prime_under(n)."
  :test "def test_max_prime_under( )
  assert max_prime_under(10) == 7
  assert max_prime_under(pow(2,16)) == 6552
  assert max_prime_under(pow(2,31)) == 2147483647"}

 {:problem "正数 n を超えない 2 番目に大きい素数を返す関数 submax_prime_under(n)."}

 {:problem "n 未満の素数の和を求める関数 sum_primes_under(int n).
            sum_primes_under(1000) は 76127 のはず。"}

 {:problem "4 番目までの素数を足すと 2 + 3 + 5 + 7 = 17.
            1000 番目までの素数の和を求めなさい。それはたぶん 3682913."}

 ;; lists
 {:problem "リスト xs の各要素を n 倍したリストを返す関数 times_n(xs, n)."}

 {:problem "リスト xs の偶数番めの要素だけを抜き出したリストを返す even-index(xs).
            最初の要素は 0 番目と数える。"}

 {:problem "整数リスト xs に含まれる偶数だけを抜き出す evens_only(xs)."}

 {:problem "リスト xs とリスト ys にともに含まれる要素のリストを返す commons(xs, ys)."}

 {:problem "リスト xs から重複を除いたリストを作って返す distinct(xs)."}

 {:problem "リスト xs とリスト ys から作った重複要素のないリストを返す
           distinct(xs, ys)."}

 {:problem "要素 e が m 個あるリストを返す関数 repeat_item(e, m)."}

 {:problem "リスト xs の要素をそれぞれ2個に増やす関数 dupli(xs).
           dupli([1, 2, 3]) は [1, 1, 2, 2, 3, 3] を返す。"}

 {:problem "リスト xs の要素をそれぞれn 個に増やす関数 repli(xs).
           repli([1, 2, 3], 3) は [1, 1, 1, 2, 2, 3, 3, 3, 3] を返す。"}

 {:problem "リスト xs から連続する要素を削除したリストを返す dedupe(xs).
           dedupe([1, 1, 1, 2, 2, 3, 3, 3, 3]) の戻り値は [1, 2, 3]. "}

 {:problem "リスト xs を圧縮する関数 compress(xs).
           compress([3, 3, 3, 'a', 'a', 1, 'b', 'b', 'b']) の戻り値は
           [[3, 3], ['a', 2], [1, 1], ['b', 3]] になる。"}

 {:problem "compress( ) によって圧縮されたリストを元に戻す関数 expand( ).
           expand([[3, 3], ['a', 2], [1, 1], ['b', 3]]) の戻り値は
           [3, 3, 3, 'a', 'a', 1, 'b', b', 'b'] になる。"}

 ;; range
 {:problem "正数 n から m-1 (n &lt; m) までの整数のリストを関数 range( ) で作れ。"}

 {:problem "正数 n から m-1 (n &lt; m) まで、step ごとの整数のリストを関数 range( ) で作れ。"}


 ;; dictionary
 {:problem "月の名前を文字列 s で取り、その月の日数を返す関数 days(s)."}

 {:problem "月の名前を文字列 s で取り、その月の日数を返す関数 days(s)."}

 ;; mathematics
 {:problem "（孫子の問題）3 で割って1余り、5 で割って2余り、7 で割って 3 余る正の整数の最小のものはなにか？"}

 {:problem "一次方程式 ax = 0 を [a, b] で表すものとし、
           solve_1([2,4] が 2x + 4 = 0 の解、x=2 を返すような関数 solve_1( )."}

 {:problem "連立方程式 ax + by = c, dx + ey =f を [[a, b, c], [d,e,f]] で表す。
           solve_2([[1, 2, 3], [4, 5, 6]]) により x + 2y = 3, 4x + 5y = 6 の解を
           求める関数 solve_2( )."}

 ;; {:problem "10000 未満の素数 p1, p2, p3 で、p1<sup>2</sup> + p2<sup>2</sup> = p3<sup>2</sup>を満たすものを探せ。"}

 {:problem "2520 は 1 から 10 の数字のすべての整数で割り切れる最小の整数である。
            1 から 20 までの整数すべてで割り切れる最小の整数は何か？"}

 {:problem "正の整数 n を素因数分解する関数 factor_integer(n).
            戻り値は素因数のリスト。"}

 {:problem "600851475143 の素因数のうち最大のものを求めよ。スピード勝負！"}

 ;; square, cubic,...
 {:problem "整数 n が平方数であるかどうかを判定する関数 is_square(n).
            237169 は平方数である。"}

 {:problem "整数 n が立方数であるかどうかを判定する関数 is_cubic(n).
            9663597 は立方数である。"}

 {:problem "整数 n が 二つの整数の2乗の和として表されるかどうかを判定する関数
            is_squeare_sum(n).
            is_square_sum(30505) は True を返す。"}

 {:problem "整数 n のルートを超えない最大の整数を返す関数int sqrt_int(int n).
            sqrt_int(24) の戻り値は4, sqrt_int(25)の戻り値は 5 を期待する。
            ライブラリ sqrt を使わずに解くこと。"}

 {:problem "1000000 未満の整数で、平方数かつ立方数でもある最大の数は何か。
            square_cubic(int n). square_cubic(1000000) の戻り値はきっと、531***."}

 {:problem "n を整数とする。factorial(n) + 2 が立方数となるような n を全て求めよ。"}

 ;; floating numbers
 {:problem "小数点数 x を四捨五入した整数を返す関数 f_to_i(x).
            注意: python の関数 round( ) だと、
            round(2.5) が 2 になってちょっとまずい。"}

 {:problem "小数点数 x を小数点第 2 位で四捨五入した数を返す関数 f_to_f1(x).
            f_to_f1(3.14159265) の戻り値は 3.100000 になる"}

 {:problem "小数点数 x を小数点第 n+1 位で四捨五入した数を返す関数 f_to_f( x, n).
            f_to_f(3.14159265, 4) の戻り値は 3.141600になる。"}

 ;; files
 {:problem "ファイル<a href='integers.txt'>integers.txt</a> をダウンロードし、適当な場所にセーブしてください。ファイル 'numbers.txt' には一行にひとつ、整数が書き込まれている。そのファイルの1行目の数を返す関数int head(void)."}

 {:problem "ファイル 'numbers.txt' が何行あるかを返す関数int lines(void)."}

 {:problem "ファイル 'numbers.txt' の n 行目の数字を返す関数int nth(int n)."}

 {:problem "ファイル 'numbers.txt' の最初の十行に含まれる整数の総和を返す関数int sum10(void)."}

 {:problem "ファイル 'numbers.txt' の最初の n 行に含まれる整数の総和を返す関数int sum_n(int n)."}

 {:problem "ファイル 'numbers.txt' の最後の n 行に含まれる整数の総和を返す関数int sum_tail(int n)."}

 {:problem "ファイル名を文字列 fname として引数にとり、そのファイルの中身を表示する関数 void cat(char *fname)"}

 {:problem "ファイル名を文字列 fname として引数にとり、そのファイルの中身を行番号つきで表示する関数 void n_cat(char *fname)"}

 ;; recursion
 {:problem "関数 factorial(int n) を定義せよ。factorial(5) は 5! の値を戻り値とする。一般に factoria(n) = n * factorial(n-1).0! は 1 だよ。"}

 {:problem "フィボナッチ数列を計算する関数  fibo(n) を定義せよ。
           fibo(0) = 0, fibo(1) = 1, fibo(n) = fibo(n-1) + fibo(n-2)."}

 {:problem "フィボナッチ数が最初に n を超えるのはいくらかを求める関数
            fibo_over(n). fibo_over(20000) の戻り値はきっと 23."}

 {:problem "n 以上 m 未満となるフィボナッチ数の総和を返す関数
           sum_fibo_between(n, m).
           sum_fibo_between(10000, 100000) の戻り値は 178700 よりちょっと大きい。"}

 ;; strings
 ;;
 ;; s.replace(s1,s2)
 ;; s.index(s1)
 ;; s.count(s2)
 ;; s.strip( ), lstrip( ), rstrip( )

 {:problem "文字列 s が空文字列 '' かどうかを判定する関数 is_empty(s)."}

 {:problem "文字列 s を逆にした文字列を返す関数 str_reverse(s)."}

 {:problem "'Kimura Takuya' のような文字列 s を引数とし、
           そのイニシャル 'K.T.' を返す関数 initial(s)"}

 {:problem "文字列 s に含まれる文字 c の数を返す関数 count_char(s, c)."}

 {:problem "文字列 s に含まれる単語の数を返す関数 count_word(s)."}

 ;; {:problem "二つの文字列 s1, s2 の先頭の n 文字が
 ;; 等しいかどうかを判定する関数 str_eql_n(s1, s2, n)."}

;; {:problem "文字列 s1 と文字列 s2 が完全に等しいかどうかを判定する関数 str_eql(s1, s2)."}

;; {:problem "文字列 s1 を文字列 s2 にコピーする関数void str_copy(s1, s2)
;;  s2 は s1 をコピーするに十分な長さがあると仮定してよい。以下同様。
;;  str_copy(s1,s2) の実行後、str_sql(s1, s2) が真になること。"}

;; {:problem "文字列 s1 の後ろに文字列 s2 を連結する関数char* str_append(char* s1, char* s2).str_append(" abc ", " def ") の実行後、str_eql(s1, " abcdef ")は真になる。s1 を破壊しないバージョンも作ってみよう。s1 と s2 を連結した文字列を返すように。"

 {:problem "文字列 s1 中に文字列 s2 が出現するかどうかを判定する関数
  str_search(s1,  s2).
  s2 が s1 の何文字目から出現しているかを返す。見つからなかった時は -1 を返せ。
  戻り値 が 0 の時は「s1 の先頭に s2 は見つかる」の意味になる。"}

 {:problem "文字列 s の n 文字目からの m 文字を削除した文字列を返す
  str_remove(s1,  n,  m)."}

 {:problem "文字列 s1 中に現れる文字列 s2 を文字列 s3 で置き換えた文字列を返す
  str_subst(s1, s2, s3)."}

;; {:problem "文字列 s1 を整数に変換して返す関数  str_to_int(s1). str_to_int('314')の戻り値は 314 になる。
;;  int(314)."}

;; {:problem "n * m と同じ計算をする関数  stoic_times(int n,  m) を定義せよ。負の数も考慮すること。stoic_times( ) ほか、補助関数中でも * を使うのは反則とする。"}

;; {:problem "++ と -- のみを使い、x + y と同じ計算をする関数  stoic_add(int x,  y) を定義せよ。負の数も考慮すること。"}

 {:problem "4/(1+x<sup>2</sup>) を x について 0 から 1 まで積分すると pi になる。これをスマートにプログラムしてください。"}

 ;; speed

 ;; numpy, 50x faster?
 {:problem "numpy 50x faster?"}

 ;; matplotlib
 {:problem "matplotlib, how to?"}

 {:problem "99題にしぼらないと。"}]
